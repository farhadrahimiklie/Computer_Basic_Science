

## **1. The Problem Paging Solves**

Modern OSes need to manage memory efficiently. Let's consider problems:

### a) Contiguous Allocation

* Old systems required a process to have **continuous memory blocks**.
* Problems:

  * **External Fragmentation**: Free memory exists, but not in large contiguous blocks.
  * **Inefficient Memory Utilization**: Even if enough total free memory exists, a process may not fit because the free memory is fragmented.

### b) Solution: Paging

* Break **physical memory** into **fixed-size frames**.
* Break **logical memory (process memory)** into **fixed-size pages**.
* Map **pages → frames**, so physical memory can be non-contiguous.
* Frame size = Page size = typically 4 KB, 8 KB, 16 KB depending on architecture.

---

## **2. Paging Terminology**

| Term         | Definition                                         |
| ------------ | -------------------------------------------------- |
| Page         | Fixed-size block of **logical/virtual memory**     |
| Frame        | Fixed-size block of **physical memory**            |
| Page Table   | OS data structure mapping **pages → frames**       |
| Page Number  | The index of a page in logical memory              |
| Frame Number | The index of a frame in physical memory            |
| Page Offset  | Offset within a page (logical address % page size) |

---

## **3. How Paging Works – Step by Step**

Logical (virtual) address generated by CPU:

```
| Page Number | Page Offset |
```

1. CPU generates a **logical address**.
2. Page number is used to **index the page table**.
3. Page table provides the **frame number**.
4. Physical address = `frame number * frame size + page offset`.
5. Memory access is completed.

---

### **Example Calculation**

* Logical address space = 64 KB
* Page size = 4 KB
* Physical memory = 32 KB

**Step 1: Divide memory into pages/frames**

* Number of pages = 64 KB / 4 KB = 16 pages
* Number of frames = 32 KB / 4 KB = 8 frames

**Step 2: Mapping pages to frames**

| Page | Frame |
| ---- | ----- |
| 0    | 5     |
| 1    | 2     |
| 2    | 7     |
| 3    | 1     |
| ...  | ...   |

**Step 3: Address translation**

Logical address = 0x1234

* Page number = 0x1234 / 0x1000 = 1 (integer division)
* Page offset = 0x1234 % 0x1000 = 0x234
* Frame number = page table[1] = 2
* Physical address = 2 * 0x1000 + 0x234 = 0x2234

✅ Done.

---

## **4. Types of Paging**

### a) Simple Paging

* Single-level page table
* Works well for **small logical address spaces**
* Problem: Page table can be **very large** for 32-bit or 64-bit addresses

### b) Hierarchical Paging (Multi-level Paging)

* Break page tables into **levels**
* Example: 32-bit address:

  ```
  10 bits → first level page table
  10 bits → second level page table
  12 bits → page offset
  ```
* Reduces memory used for page tables.

### c) Inverted Paging

* Instead of per-process page tables, maintain **one global table** with **frame → process mapping**
* Saves memory but **slower lookups**.

---

## **5. Advantages of Paging**

1. Eliminates **external fragmentation**.
2. Simplifies **memory allocation**.
3. Supports **virtual memory**.
4. Provides **memory protection** per page.

---

## **6. Disadvantages of Paging**

1. **Internal Fragmentation**: Last page may not be fully used.
2. **Page table overhead**: Large page tables require extra memory.
3. **Translation overhead**: Each memory access requires page table lookup (can be reduced by **TLB – Translation Lookaside Buffer**).

---

## **7. Page Tables and TLB**

### Page Table Structure

```c
struct page_table_entry {
    int frame_number;
    int valid; // 1 if page is in memory, 0 if not
};
```

### CPU + OS operation

1. CPU generates **virtual address**
2. OS checks **TLB** (fast cache for page table entries)
3. If hit → frame number is retrieved quickly
4. If miss → access page table in memory → slower

**C Simulation of Page Table Access**

```c
#include <stdio.h>
#define PAGE_SIZE 4096
#define NUM_PAGES 16
#define NUM_FRAMES 8

int page_table[NUM_PAGES] = {5, 2, 7, 1, 0, 3, 4, 6, -1, -1, -1, -1, -1, -1, -1, -1};

int logical_to_physical(int logical_address) {
    int page_number = logical_address / PAGE_SIZE;
    int page_offset = logical_address % PAGE_SIZE;
    
    if(page_number >= NUM_PAGES || page_table[page_number] == -1) {
        printf("Page fault at page %d!\n", page_number);
        return -1;
    }

    int frame_number = page_table[page_number];
    int physical_address = frame_number * PAGE_SIZE + page_offset;
    return physical_address;
}

int main() {
    int logical_address = 0x1234; // Example
    int physical_address = logical_to_physical(logical_address);

    if(physical_address != -1)
        printf("Logical Address: 0x%x -> Physical Address: 0x%x\n", logical_address, physical_address);
    return 0;
}
```

Output:

```
Logical Address: 0x1234 -> Physical Address: 0x2234
```

✅ This is exactly the calculation we did manually earlier.

---

## **8. Paging With Virtual Memory**

Paging allows **virtual memory**, where pages not in physical memory can be **stored on disk**. Steps:

1. CPU references a page not in memory → **page fault**
2. OS finds a free frame or replaces a frame (**page replacement**)
3. Disk page is loaded into frame
4. Page table is updated
5. CPU retries instruction

Page replacement algorithms:

* FIFO
* LRU (Least Recently Used)
* Optimal

---

## **9. Summary of Paging Flow**

1. Process generates **logical address**
2. Split logical address → **page number + page offset**
3. Use **page number → frame number** from page table
4. Combine **frame number + page offset → physical address**
5. Access memory
6. If page not in memory → **page fault**, handle it

---

## ✅ Key Takeaways to Master Paging

1. **Paging solves external fragmentation**
2. **Page size matters** → smaller pages → less internal fragmentation, but bigger page tables
3. **Page tables are critical** → single-level vs multi-level vs inverted
4. **TLB is essential** → reduces overhead of page table lookups
5. **Virtual memory + paging** → allows processes to use more memory than physically available
6. **Page replacement algorithms** → crucial for OS performance



